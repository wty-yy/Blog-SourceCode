---
title: 2023算法复习
hide: false
math: true
abbrlink: 35639
date: 2023-05-07 23:28:00
index\_img:
banner\_img:
category:
tags:
---

> 使用[vjudge](https://vjudge.net)进行题目评测，减少找题的工作量。

`~/.vimrc` 中g++使用F5快速执行代码，
```vimrc
autocmd filetype cpp nnoremap <F5> :w <bar> !g++ % -o %:r && ./%:r<CR>
```


##### 2023.4.24.
《第一章 算法设计基础》
1. UVA - 11292 - Dragon of Loowater 贪心，双指针
2. UVA - 11729 - Commando War 贪心
    证明贪心的正确性，基于一个先假设好的条件，分类讨论结果，比较结果的正确性，使用 (Job){a, b} 对结构体赋予初值
3. UVA - 11300 - Spreading the Wealth 思考题
    将题目中的变量设出来，得到n个变量和n-1个方程的方程组组，通过其中一个变量x1将其他变量表示出来，再将目标最小化结果由单变量表示出来，发现是一个一维绝对值之和最小化问题，取中位数即可（反证法证明）
4. CF Gym NEERC 2006 - 100287G - Graveyard 贪心
    非常具有技巧性的题目，首先阅读题目有些难度，主要要注意到equidistant和memorial两个含义，首先用到**等距缩放**的技巧，并对雕像进行**编号**，这样就能把圆上的问题转化为一维整数点区间上的问题，并用贪心进行求解非常巧妙：将加入新雕像后的坐标作为整数坐标，总距离为(n+m)，就雕像位置在该坐标尺度下表示出来（小数形式），再将每个雕像移动到最近的整点坐标即可(四舍五入)，最后再证明贪心的正确性。
5. UVA - 10881 - Piotr's Ants 思路题
    蚂蚁碰头之后会反向移动，容易发现一点是蚂蚁之间的相对位置是不会变换的，最重要解题点是将蚂蚁的碰头视为相互穿过。
    于是只需先假设蚂蚁是相互穿过的，然后再排序得到相对顺序，再通过初始的相对顺序order[i]，最终根据相对序号的一致性，得到每个编号的蚂蚁的最终位置。
    注：数轴长度为L，并从0开始。
6. UVA - 1030 - Image Is Everything 暴力模拟题
    题目要求最大的正方体方块个数，也就是挖去所有产生矛盾的方块，剩下的非空方块个数就是最大个数，所以只需要找出所有一定有矛盾的方块：
    1. 如果某个视图上为 `'.'` 则全部深度的方块均为空。
    2. 暴力枚举**每个视图上的每个位置的所有深度**，对立方体建立坐标系，定义函数$\text{视图相对坐标+深度}\mapsto \text{立方体方格坐标}$，判断当前方格的颜色是否和当前视图中的颜色一致，如果一致则跳过后续深度枚举，否则将其挖去，继续枚举后续深度。
- 技巧：
    - 利用宏函数 `#define rep(i, n) for (int i = 0; i < n; i++)` 可以大幅减少 `for` 循环的冗余，使代码更加简洁易读。
    - 对于多个返回值的函数，无需对其进行返回，而是使用传递实参的方式进行返回。
7. Codeforces Round 867 (Div. 3)
    比较简单的比赛，但是由于不理解题意没有打好。看复杂题面的题，首先找题目求解的问题关键词：Answer, You need, Formally ... ，再通过题目给出的样例进一步分析题意，最后确定有哪些变量需要开 `long long`
    1. 两道题，没有仔细开 `long long` 导致错误提交，也就是思路还不够清晰。
    2. F题，树的边数组开小了1个，树上dp找每个节点u第一和第二长的路径 `mx[u][0]` 和`mx[u][1]`，只需两次dfs，固定一个节点为根节点，第一次dfs求出每个节点到叶子节点的第一二大的距离，并存储下最大距离是从 `frome[u]` 节点转移得到的，第二次dfs可得每个节点上方的最大距离（注意如果是递推到 `from[u]` 节点则其最大距离为 `max(rtlen, mx[u][1] + 1)`）。
    3. D题，容易想到不是解的必要条件：n>1且为奇数则一定不是解；还是考虑构造从而得出其充分性，首先a的第一个一定是n，构造的技巧是利用每个元素的范围有限[1,n)，保持构造的结果具有某种递增的规律（围绕某个元素进行构造），在模意义下构造出a=[1,-2,3,-4,5,-6,...,-(n-2),n-1]。

##### 2023.4.25.
8. UVA - 11464 - Even Parity 暴力
    通过每个点四周必定为偶数个黑点，如果确定了前两排的结果，那么第三排的状态就可以唯一确定了，所以我们只需要暴力枚举第一排，于是之后的每一排都唯一确定了（一个十字架，上面三个顶点的值确定，总和为偶数，那么下面的值一定可以确定下来）
9. UVA - 1352 - Colored Cubes 暴力
    首先对正方体进行编号，枚举正方体的全部旋转方法24种，打表；然后对实际的5个正方体逐个枚举旋转方法，复杂度为O(24^3)，对于每个面，全部染为有最多共同颜色的面，取最小的染色方法。
注：能不用 `#include <bits/stdc++.h>` 就不要使用，会大幅度降低编译速度，并且有变量重名的可能。
10. UVA - 11210 - Chinese Mahjong 暴力
    麻将题，注意枚举顺序：依次枚举听牌，将牌，刻子和顺子。灵活运用 `string` 数据类型进行牌型判断，用`s.c_str()` 转为 `char*` 输出 `string` 类型；注意输出结果的空格细节。
11. UVA - 11384 - Help is needed for Dexter 简单题
    非常简单，找到规律就是log2n向下取整+1
12. UVA - 10795 - A Different Task 数学题
    巧妙的利用了汉诺塔的性质，一定要移动的一定是最大的终止状态和初始状态不同的大小为k的圆盘，所以一定要把1...k-1移动到唯一多余的柱子上这个状态成为中间状态，利用移动圆盘的对称性，只需将初始和终止两个状态的圆盘都移动到该中间状态上，再+1就得到答案了。
    巧妙的构造递归函数f(P, i, final)，这和dp类似，P表示开始状态，i表示最大的圆盘，final是将1...i-1圆盘全部移动到final柱子上，递推方法也是类似的思路，看最大的圆盘位置有没有移动，如果`final[i]!=P[i]`，说明1...i-1都要先移动到`6-final[i]-P[i]`上，然后将1...i-1移动回final[i]，这一步就是传统的汉诺塔，直接给出步数`2^(i-1)=1+2+...+2^(i-2)`。

##### 2023.4.26.
13. UVA - 12124 - Assemble 二分答案
    最小值最大问题，显然二分答案，利用结构体存储每个类型的物品，注意到结果中没有涉及到部件的名称，所以无需存储名称。

    注意：**使用下标枚举vector中的数据**，而不是使用速度慢的 `for (auto x : v)`（慢20倍左右）。
14. CF Gym NWERC 2006 - 100722C - Pie 二分答案
    非常简单，只需二分枚举派的大小即可。使用 `const double PI = acos(-1.0)` 定义PI。
15. UVA - 11520 - Fill the Square 暴力枚举
    非常简单，从小到大枚举字符即可。

    注意：**字符串数组必须至少为最大字符串长度+1**，因为有终止符 `0` 存在。
16. UVA - 1267 - Network 贪心
    贪心地每次从距离根服务器最远的节点开始向上找最远的祖先节点放置服务器镜像，注意使用链表从边的编号从0开始存图每次要初始化所有的 `head[u]=0`，并初始化 `ecnt=0`。
17. UVA - 1335 - Beijing Guards 二分答案，巧妙的贪心判断结果
    求解环形问题第一步一定是确定基准元，然后**分析二分的上下界**（非常重要，一定要想清楚），下界一定是两个相邻的礼物需求之和的最大值，上界是最大礼物需求的三倍；最巧妙的是，贪心判断是否可行时，顺次贪心选取的礼物数量只不过方向正好相反，第0个从左开始选r[0]个，第1个也从左选r[0]个，第2个从右选r[0]个，最后判断n-1个从右选的r[n-1]个是否和第0个选的r[0]个重复；但是这样检查一次的复杂度是O(n^2)，注意到题目没有要求具体礼物的编号，并且我们只关心第n-1和第0个人是否选取重复，所以可以以**第0个选取的礼物将全部礼物划分为左右两部分**，后面的每个人只需考虑在两个部分中各选了多少个即可，最后判断最后一个人有没有在左边选取礼物即可。
    注意：
    1. 二分的上下界分析（必要性），对于判断函数 `check()` 也可以缩小判断范围。
    2. 边界条件n=1的判断。
    3. 二分答案的两种写法：
```cpp
int L, R;
// 最小化二分
while (L < R) {
    int mid = (L + R) / 2;
    if (check(mid)) R = mid;  // 如果mid可行
    else L = mid + 1;
}
// 最大化二分
while (L < R) {
    int mid = (L + R + 1) / 2;
    if (check(mid)) L = mid;  // 如果mid可行
    else R = mid - 1;
}
// 两种写法二分结果均为L
return L
```
18. UVA - 11462 - Age Sort 桶排序
    没什么技巧，只需注意末尾不要有多余空格。
19. UVA - 11078 - Open Credit System 贪心，简单题

##### 2023.4.27
20. UVA - 11549 - Calculator Conundrum 暴力
    利用Floyd判圈算法通过两个节点的运动速度不同（一个运动速度为1，另一个为2），从而在O(n)时间下找大小为n的环。
21. UVA - 1398 - Meteor - E4 代数几何，线段最大交集
    仅考虑**对答案产生贡献**的时间段，用结构题存储区间的端点，由于每个时间段均为开集，在用扫描线处理到相同位置的边界点时，优先处理右端点（如果是闭集则优先处理左端点）
22. UVA - 1330 - City Game - E1 代数几何，最大化矩形面积
    考虑点(i,j)向上扩展出的最大距离记为up(i,j)，向左右按照上方最大距离能扩展的最大距离分别记为left(i,j),right(i,j)，于是这个点按照向上最大距离能扩展的最大面积为`(right(i,j)-left(i,j)+1)*up(i,j)`。
    进一步考虑用迭代方式求解这三个数组，不难发现`up(i,j)=up(i-1,j)`，顺次从上到下，以横向扫描线扫描没一行，从左到右更新left，如果`up(i-1,j)<up(i,j)`则`left(i,j)=1`，否则`left(i,j)=left(i-1,j)`；right数组从右到左更新，方法类似。
23. UVA - 1382 - Distant Galaxy - E1 代数几何，最大化矩形边界点
    找矩形上一定存在的条件：每条边上至少有一个点，于是转化为通过点枚举边，枚举四条边有点多了，所以就枚举上下两条边（按照y轴枚举，需要对y轴进行排序，顺便去重，方便枚举），然后找再两条矩形的竖线构造出矩形，现在考虑如何快速求出最大的边界点，首先考虑矩形的边界点可以通过哪些变量求出，left[i],on[i],on2[i]分别表示第i个竖线左侧在上下两边上的点数目（不包括i）、第i个竖线上夹在上下两边中间的点数（不包括两边）、第i个竖线上夹在上下两边中间的点数（包括两边），于是第i,j竖线构成的矩形上的点可以表示为`left[j]-left[i]+on2[j]+on[i]`，求(i,j)使得递推式最大化，可以从左至右顺次枚举，记录下`on[i]-left[i] (i<j)`的最大值mx，于是`left[j]+on2[j]+mx`就是矩形右直线为j能覆盖的最大点数。
24. UVA - 10755 - Garbage Heap - E1 代数几何，容斥原理
    先从求二维面积最大矩形权重之和考虑，通过维护前缀和，枚举矩形边界y1,y2，再从小到大枚举x，通过前缀和求出{(1,y1),(x,y2)}的权重之和，记录下前面扫描过的最小值，则最大权重是当前的权重之和减去之前的最小值。
    三维方法类似，主要是怎么求出前缀和，考虑二位的容斥原理，每次要求出{(x1,y1),(x2,y2)}的面积，就是通过s(x1,y1)减去s(x1,y2)和s(x2,y1)的并，这个并可以通过容斥原理得到：s(x1,y2)+s(x2,y1)-s(x2,y2)
    类似的三维也是通过s(x1,y1,z1)减去s(x2,y1,z1),s(x1,y2,z1),s(x1,y1,z2)的并，通过容斥原理可得：s(x2,y1,z1)+s(x1,y2,z1)+s(x1,y1,z2)-s(x2,y2,z1)-s(x2,y1,z2)-s(x1,y2,z2)+s(x2,y2,z2)
    最后也是枚举六面体边界x1,x2,y1,y2，再从小到大枚举z，与二位相似的操作即可求出三维权重最大值。
25. CF Gym - 101388J - Jurassic Remains - E0 位运算，折半枚举
    难度最大的是读懂这个题目，题目说是要骨头配对，其实就是骨头上关节的编号配对，也就是每个编号至少能有一对，也就是每个字母出现的次数一定要是偶数次，所以可以想到用异或运算解决。
    由于编号只有26种，骨头数目也不超过26个，先将骨头的编号转为对应的二进制位，一个集合中所有骨头的编号异或起来如果是0则满足题意，再通过折半枚举，先枚举n/2个骨头的所有编号组合，并用map的key值记录编号组合，value值记录选择的骨头（相同则取骨头集合中元素最多的），然后在枚举另一半的所有骨头编号组合，判断是否在map中有对应的key值即可，复杂度`O(2^(n/2)log(2^(n/2)))=O(n/2*2^(n/2))`。

##### 2023.4.29. 算法复习计划1
- [x] DP平行四边形不等式优化、单调队列优化
- [ ] Trie
- [ ] KMP
- [ ] 线段树
- [ ] SAM
- [ ] Tarjan
- [ ] 二分图匹配

##### 2023.4.30. 初步学习四边形不等式DP优化
25. 洛谷 - P3515 - Lightning Conductor 平行四边形不等式DP优化-1
    要求 `p[i] = max{h[j]-h[i]+sqrt(abs(i-j)) : 1<=j<=n}`，先转化为 `min` 问题，然后发现极小化函数为 `h[i]-h[j]-sqrt(abs(i-j))` 记极小值为 `f[i]`，通过分类讨论可以把绝对值去掉 `abs(i-j)=i-j, i > j`，只要注意到 `-h[j]+h[i]`，`i-j` 都满足平行四边形恒等式，且 `-sqrt(x)` 为凸函数，所以 `-sqrt(i-j)` 满足平行四边形不等式，故 `f[i]` 最优决策 `k[i]` 单调递增，可以使用分治法求解。
    技巧：由于要讨论 `i<j` 和 `j > i` 两种情况，所以可以通过将数组 `h, f` 进行反转后，用同一个DP分治函数即可实现两种情况。
26. POJ - 2823 - Sliding Window 连续区间最值RMQ查询，单调队列
    经典单调队列例题，滑动窗口区间最值查询写为数学表达式就是 `f[r] = max{a[l] : r-k<l<=r}`，单调队列可以实现处理极大极小值问题时，当决策空间在状态域上具有单调性，则可以通过从小到大枚举状态值 `r`，并用单调队列维护当前可行的最优解即可。复杂度O(n)。
27. 洛谷 - P2698 - Flowerpot S 连续区间最值查询，单调队列
    本题中区间长度未知，要求求出最小的区间长度 `len` 使得存在 `r-l=len` 有 `max A[j] - min A[j] >= d` 成立（分别取区间最大值和最小值），首先可以二分答案，用单调队列check，复杂度O(nlogn)；然而这题有不用二分答案的方法，要发现当固定左端点 `l` 时，目标函数是关于右端点 `r` 单增的，所以如果 `[l,r]` 满足题意，则 `[l,r+1]` 也能满足题意，也就是最小的满足题意的 `r` 就是我们要求的最小长度，所以可以枚举 `r`，每次区间 `[l,r]` 满足题意，逐步增加 `l` 直到不再满足题意为止，中间记录下最小值就是答案，复杂度O(n)。
28. CodeForces - 372C - Watching Fireworks is Fun 单调队列优化DP
    本题是1D1D型DP，`f(i,j) = max{f(i-1,k):|k-j|<=d*(t[i]-t[i-1])}+b[i]-|a[i]-j|`，注意到更新区间 `[j-d*(t[i]-t[i-1]), j+d*(t[i]-t[i-1])]` 是随j连续变换的，所以可以直接用单调队列维护 `max{f(i-1,k)}`。
    注意：循环区间条件的成立性，要将 `pop_front` 放在 `pop_back` 循环外，否则有时候不进入循环则无法执行 `pop_back`，以保证取到的都是在合法区间内的。

##### 2023.5.1.
29. 洛谷 - P3195 - 玩具装箱 单调栈实现1D1D平行四边形不等式优化DP
    需要非常深刻的思考，做了详细的笔记。单调栈实现的方法是一般化方法，比分治法更好，实现上也就是四步，计算新状态值、弹栈、二分、入栈。
30. 洛谷 - P6932 - WF2017D Money for Nothing 分治法实现平行四边形不等式优化DP
    DP函数不难写出`max{(d[r]-d[l])*(p[r]-p[l]}`，首先贪心考虑一个商家的(d,p)值，如果`di<dj`且`pi<pj`则商家j一定不如商家i好，所以可以直接将j去掉；买家同理，如果`di>dj`且`pi>pj`则买家j一定不如买家i好，直接将j去掉。于是我们得到了买家和卖家的p关于d单调递减的离散函数，根据这个就可以证明`w(l,r)=(d[r]-d[l])*(p[r]-p[l])`是满足交叉大于包含的平行四边形不等式，所以满足决策单调性，于是用分治法即可解决（应该不能用单调栈解决吧，单调栈解决应该要求决策点和状态值是同一个集合中）

##### 2023.5.2.
31. UVA - 10859 - Placing Lampposts 树形DP
    通过求解技巧在于转换问题，是两个极小化条件，首要条件是灯的数目最少，在灯数目最少前提下，要求每个两段都有灯的边尽可能多（等价于一端有灯的边数最少），可以通过加入大常数M，将这两个问题转化为一个最优化表达式：设灯的数目为a，只有一段有灯的边数为b，且M大于b的上界，则该问题等价于最小化x=Ma+b。这样x/M就是边的数目，x%M就是只有一端有灯的边数。进一步设计状态，f(i,j)表示第i个节点的父节点灯的状态为j的最小x值，通过讨论第i个节点是否放灯进行状态转移，每棵树上进行一次dfs即可（森林中只需每次处理一颗树）
32. UVA - 1169 - Robotruck - E3 单调队列优化DP
    通过转化状态转移方程（将区间求和用前缀和表出，与当前状态值i相关的变量就是常量可以提到min\max外部），再观察决策值集合是关于i严格递增的并且dp的状态值仅和j相关，所以可以使用单调队列优化。
33. 蓝桥杯练习题 - 第二届省赛 - 前四道题

##### 2023.5.3.
34. 蓝桥杯练习题 - 第二届国赛 - 两道题, 第三届省赛 一道题：
    查找循环节：有理数a/b，只需记录每个小数点后第i位的值为A[]，并记录计算每个小数点时分子对应值a，与小数点位置的对应关系pos[a]=i（可以用map实现，因为a的最大值是分母的10倍），求小数点后第i位就是 `(a*10^(i-1)%b)*10/b`，其实只需保留上次小数点分子的值 `a`，然后 `a*10/b` 就是当前小数点的值。
35. UVA - 1099 - Sharing Chocolate 状压DP
    利用二进制表示是否选择某个元素的集合（状压），首先想到构建f(x,y,S)表示是否可以通过x行y列的巧克力划分出集合S，然后发现三者必然满足xy=sum(S)，于是又可以将状态减少到两个，y=sum(S)/x，表示为f(x,S)，由于f(x,y,S)=f(y,x,S)，于是又可以每次将行与列中较小者作为状态值x，并且状态转移时只需枚举子集合S0，因为当固定x或y不变时，可通过S0计算出另一个变量例y0=S0/x，最后是枚举子集合的方法：`for (int S0 = (S-1)&S; S0; S0 = (S0-1)&S0)` 结果与dfs暴力枚举（优先枚举1）效果相同。
    注意：记忆化搜索实现dp时，使用 `int& ans = f[i][j];` 然后最后返回时记录 `return ans = 状态值;`，并使用 `vis[i][j]` 记录下该状态是否访问过，如果访问过则直接返回 `f[i][j]`。
36. UVA - 11825 - Hackers' Crackdown 状压DP
    本题是很巧妙的问题转换，最大化指标集划分个数，且每个指标集划分中集合之并都是全集，以指标集S作为状态值，转移通过枚举子集S0，并且需要S0指标对应的集合并是全集，则可转移 `f(S)=max{f(S-S0)}+1`。
    注意：本题可以不用记忆化搜索直接`for`循环完成，因为可以从小到大枚举状态值S，从而保证转移时子状态的dp值一定是存在的。上一题不好使用 `for`，也正是因为无法保证子状态的dp值在之前是枚举过了的。
37. UVA - 11995 - I Can Guess the Data Structure! 简单题
    判断是否满足栈、队列、优先队列三种数据结构。
    注意：实现队列时 `queue[front++]` 是弹出操作（不是 `front--`）
38. UVA - 11991 - Easy Problem from Rujia Liu? 简单题
    先用map编号在放入vector数组中，可以直接用 `map<int, vector<int> >` 代替。
39. POJ - 2051 - Argus 优先队列简单题
    读入结构体中部分元素值时，可以先构建一个结构体实例，然后输入到该实例中。
40. UVA - 11997 - K Smallest Sums 优先队列合并多个递增序列（多路合并）
    核心是利用不等号对加法的保号性（如果问题改成乘法，应该只需合并单减和单增的两个序列），将n维问题转化为两两单增序列的合并，从而从`O(k^klogk)`降到`O(k^2logk)`，考虑两个单增序列的合并方法：可以先固定一维，然后移动后一个变量
```cpp
A[1]+B[1] <= A[1]+B[2] <= ... <= A[1]+B[n]
A[2]+B[1] <= A[2]+B[2] <= ... <= A[2]+B[n]
...
A[n]+B[1] <= A[n]+B[1] <= ... <= A[n]+B[n]
```
于是变成了n路合并问题，只需要每次将每一路开头的放到优先队列中，然后就可以找到当前最小值，然后取出最小值的后继元素，继续放到优先队列里（优先队列的结构体中可以只存储`A[i]+B[j]`和`j`的值），那么合并出来的元素个数也是n个（为什么是n个呢，反证法，如果n+1可以对下一个序列产生贡献，那么一定存在之前n个中的某一个没有被选中，那么它一定小于等于n+1，所以仍然可以从前n个中的元素对后续序列产生贡献，无需n+1元素，矛盾），本质其实用到了不等号对加法的保号性，`Ai+Bj<=Ak+Bl` 则 `Ai+Bj+C<=Ak+Bl+C`（所以说如果改成乘法，我认为只需维护前n小和前n大的序列也可完成该问题），总复杂度`O(n^2logn)`。
41. UVA - 1160 - X-Plosives 并查集判环
    在没有重边下环存在的另一种说法：如果把每个端点看作不同的字母，那么环就是存在k个边，并且k个边上的端点对应了k个不同的字母，则一定有环；也就是用n条边将n个节点连接起来，不允许重边，则一定有环（证明很容易想到，因为n个节点用n-1条边连接起来必定是一棵树，一棵树上再加一条边必定出环）

##### 2023.5.4.
42. Gym - 101461B - Corporative Network - E1 并查集路径压缩
    用并查集可以动态维护每个叶子节点到根节点的距离，只需在路径压缩之前更新距离 `int rt=updatefa(u); dis[u]+=dis[fa[u]]; fa[u]=rt;`
43. UVA - 1428 - Ping pong 计数问题条件的拆分（用树状数组实现动态前缀和查询）
    问题可以转化为求解 `C[i] = #{j:A[j]<A[i],1<=j<i}`，左侧集合在i处有两个限制条件，由于A[i]和i是已知的，所以限制条件分别为 `A[j]<A[i]` 和 `1<=j<i`，暴力枚举复杂度肯定是O(nr)的（r为`A[i]`的上界），所以我们希望通过固定一个限制条件然后考虑另一个单独条件，从而完成求解，本题有两种做法：
- 第一种是固定 `1<=j<i`，然后求解 `#{A[j]<A[i]}` 的个数，由于 `A[i]` 的范围不大只有 `1e5` 所以这种方法行得通，时间复杂度O(nlogr)
- 第二种是固定 `A[j]<A[i]`，然后求解 `#{1<=j<i}` 的个数，这个方法无需 `A[i]` 的范围条件，所以时间复杂度O(nlogn)，这种方法更具一般性
```cpp
struct Bit {  // 树状数组模板
    int t[maxn];
    void init(int n) { for (int i = 1; i <= n; i++) t[i] = 0; }
    void add(int i, int x) { for (; i <= n; i += i&(-i)) t[i] += x; }
    int query(int i) { int sum = 0; for (; i; i -= i&(-i)) sum += t[i]; return sum; }
} bit;
```
44. UVA - 11235 - Frequent values - E3 区间众数（单调递增，可用树状数组实现）
    区间众数一般用分块求解，只是本题有数列单增的条件，所以相同的数一定是连在一起的，只需要记录下每段相同数的左端点和右端点，并对每段进行编号，然后将查询的区间分为三部分：`[l, min(R[l], r)], [id(l)+1, id(r)-1], [max(L[r], l), r]`，分别求出每一段的众数，中间一段可以用rmq倍增求解。
    注意：对区间进行编号时，直接对区间id进行+1或-1的操作，而不是先转移下标然后找id，也就是`id(l)+1`不一定和`id(R(l)+1)`一样，因为如果l是最右侧的一段区域，那么`R(l)+1`就没有对应区间id了。
```cpp
struct RMQ {
    int log2[maxn];
    int f[maxn][17];  // 1<<16 <= maxn && 1<<17 > maxn
    RMQ(int a[], int n) {
        for (int i = 2; i <= n; i++) log2[i] = log2[i>>1] + 1;
        for (int i = 0; i < n; i++) f[i][0] = a[i];
        for (int j = 1; (1<<j) <= n; j++)
            for (int i = 0; i + (1<<j) - 1 < n; i++)
                f[i][j] = max(f[i][j-1], f[i+(1<<(j-1))][j-1]);
    }
    int query(int l, int r) {
        if (l > r) return 0;
        int k = log2[r-l+1];
        return max(f[l][k], f[r-(1<<k)+1][k]);
    }
};
```
45. UVA - 1400 - "Ray, Pass me the dishes!" - E10! 动态区间查询最大连续和
    最大连续和如果是静态的（就是在[1,n]上求），可以直接O(n)的dp完成，用 `f[i]` 表示以 `A[i]` 结尾的最大连续和，则 `f[i] = max{A[i], A[i]+f[i-1]}` 。也可以用 O(nlogn) 的分治法完成，只需记录左右区间的最大前缀和和最大后缀和，线段树上合并的方法就类似分治法，记录每个子区间的最大前缀和和最大后缀和，然后就可以合并得到最大连续和。
    技巧：
    - 将区间的值val和左右端点用一个结构体记录，然后两个区间的比较可以根据题意，首先比较两个区间的值，然后比较左端点，最后比较右端点，注意只需重载小于号。
    - 结构体套结构体的初始化可以用 `{}` 生成写法，例如 `struct Node{Segment a, b; int l, r;}; struct Segment{int l, r;}` 于是可以直接生成`Node{ {l1,r1}, {l2,r2}, l,r}` 一个 `Node` 元素。
    注意：计算左孩子时候的位运算是 `ls=(p<<1)`，不要写反了！
46. 蓝桥杯 - 第三届省赛 - 取球游戏 NIM游戏
    由于数据量只有 `1e4`，所以直接线性递推输赢就行，`f[i]` 表示先手拿到 `i` 个球是否必胜，`f[i] = max{f(i-k)^1:k={1,3,7,8}, k<=i}`，边界 `f[0]=1`。
##### 2023.5.5.
47. UVA - 11992 - Fast Matrix Operations 线段树区间修改区间多目标查询
    由于该题存在多个线段树，所以我使用的是指针实现的线段树，无需考虑每个线段树的具体大小，但速度会满一些（没有特意卡常应该不会超时）；该题主要是需要查询三个目标包含 `sum, mx, mn`（区间和、最大值、最小值），可以设计结构体 `Segment` 存储每个节点的这三个信息，由于维护区间和还需要区间长度，所以还需记录 `len`，再设计修改函数 `set(x), add(x)`；再对线段树中每个节点设计 `Node` 结构体，该结构体中存储 `Node *ls, *rs; int l, r, addv, setv; Segment seg;` 分别表示该节点的左右儿子，左右区间端点，add操作的懒标记和set的懒标记，seg表示该节点的信息。只需注意以下几点：
    - Segment 的初始化问题，如果对答案进行合并，那么mx初始化为最小值，mx初始化为最大值。
    - 线段树中合并，在update函数结束时父节点更新子节点的区段信息 `p->seg = ls->seg + rs->seg`，在build时候直接传输 `Node*` 地址。
    - 懒标记下传，在update，query中每次进入子节点时候都要进行懒标记下传。标记下传一般分为两步，首先是树节点的 `addv, setv` 的更新，然后是区段信息 `seg` 的更新。
    注：其实 `setv` 无需存储，因为set之后一定是叶子节点，并回收内存。
48. 校赛测试4题
##### 2023.5.6.
47. SPOJ - NKMOU - IOI05 Mountains 动态开点线段树+二分查询
    需要用线段树维护前缀最大和，所以需要区间求和 `sum` 和区间前缀最大和 `mxpre`，问题查询就是线段树上二分答案，本题主要是数据范围为1e9所以不能用传统数组线段树，只能用动态开点线段树，时间复杂度只与操作数有关 `nlogn`。`set` 操作无需懒标记，因为set之后整个区间段都是一个值，所以回收内存。动态开点需要注意指针的使用，建议在传输节点时使用 `&` 而不是指针，因为 `&` 可以用 `.` 来引用内部变量，而指针需要用 `->` 比较麻烦，bug不容易看出来。
```cpp
struct Segment {  // 记录区间信息，要维护的值例如区间长度len，区间和sum，区间最大最小值mx,mn，区间最大前缀和mxpre
    LL len, sum, mxpre;
    void set(int x) { sum = len * x; mxpre = max(0LL, sum); }  // 与题目给出的区间操作对应，例如区间赋值set，区间增加某个值add
    Segment operator + (const Segment &rhs) const {  // 区间合并，用于合并两个子区间的信息
        return (Segment){len + rhs.len, sum + rhs.sum, max(mxpre, sum + rhs.mxpre)};
    }
};
struct Node {
    Node *ls, *rs;  // 1. 左右儿子指针
    int l, r, val;  // 区间的左右端点[l,r]，2. 区间的值val（全部为统一值（叶子节点）时才有作用）
    Segment seg;  // 区间段信息
    Node(int l, int r, int val):l(l),r(r),val(val) { ls = rs = nullptr; seg.len = r-l+1; seg.set(val); }  // 3. 初始化树节点，初始化只需区间的左右端点和初值，因为初始化的一定是叶子节点，所以是统一初值的
    bool isleaf() { return !ls && !rs; }  // 4. 判断是否是叶子节点，其实只需判断ls和rs其中一个
    void set(int x) { val = x; seg.set(x); del(); }  // 与题目给出的区间操作对应，如果有懒标记记得更新懒标记(addv)，5. 如果是重置set，则可以回收内存
    void create() {  // 6. 创建左右儿子节点
        if (!isleaf()) return;
        int mid = (l+r) >> 1;
        ls = new Node(l, mid, val);
        rs = new Node(mid+1, r, val);
    }
    void del() { if (ls) delete ls; if (rs) delete rs; ls = rs = nullptr; }  // 内存回收
    ~Node() { del(); }  // 7, 析构函数，在delete rt时会递归调用del，所以可以递归删除整棵树
};
Node *rt = nullptr;  // 树根节点
void build(int n) { if (rt) delete rt; rt = new Node(1, n, 0); }  // 8. 如果旧树存在则先删除，然后只需构建出新的树根节点
void pushdown(Node &p) { p.create(); }  // 下传懒标记，首先要创建左右儿子节点（如果没有），因为这只在update和query中使用到，并且只会在update处进行新节点创建，query只会下传懒标记
void update(int l, int r, int x, Node &p = *rt) {  // 这里的更新操作就是区间重置
    if (l <= p.l && p.r <= r) { p.set(x); return; }
    pushdown(p);
    int mid = (p.l + p.r) >> 1;  // 一定要根据mid进行递归方向判断，直接进入然后遇错返回会慢很多
    if (l <= mid) update(l, r, x, *p.ls);
    if (r > mid) update(l, r, x, *p.ls);
    p.seg = p.ls->seg + p.rs->seg;
}
int query(int h, Node &p = *rt) {  // 这是单点查找满足最大前缀和不超过h的节点的例子
    if (p.seg.mxpre <= h) return p.r;
    if (p.isleaf()) return p.l + h / p.val - 1;  // 10. 这里一定要判断是否是叶子节点，因为叶子节点已经是全部相同的val，可以得到要求的区间信息
    // pushdown();  // 如果有懒标记则这里也需要pushdown
    if (h >= p.ls->seg.mxpre) return query(h-p.ls->seg.sum, *p.rs);
    return query(h, *p.ls);
}
int query(int l, int r, Node &p = *rt) {  // 这是求区间和的例子
    if (p.l == l && p.r == r) return p.seg.sum;
    if (p.isleaf()) return p.val * (r-l+1);  // 10. 一定要判断是否叶子节点，并返回
    // pushdown();
    int mid = (p.l+p.r) >> 1;
    if (r <= mid) return query(l, mid, p.ls);
    else if (l > mid) return query(mid+1, r, p.rs);
    else return query(l, mid, p.ls) + query(mid+1, r, p.rs);
}
```

总的来说就是上述的10点和传统线段树不同的位置。

48. UVA - 12419 - Heap Manager 线段树动态开点+二分查询
    如果用1表示区间被占用，0表示区间空闲，则每个区间 `[l,r]` 只需维护 `pre, sub, suf` 前缀最大连续0、字串最大连续0、后缀最大连续0的长度。还是和上面的方法一致：
- 结构体 `Info` 维护区间信息，包含 `len, pre, sub, suf` 参数和重载 `+` 用于区间信息合并，本题有重置操作，所以还要 `set(x)` 函数。
- 结构体 `TNode` 维护树上节点信息，包含 `TNode *ls, *rs; int l, r, val; Info info;` 含义与上题一致。需要 `Node(l,r,val), isleaf(), set(x), create(), del(), ~Node()` 六个函数。
- 结构体 `SEG` 线段树，包含 `Node *rt` 为当前的树根节点。其他函数为 `build(n), pushdown(p), pushup(p), update(p,l,r,val), query(p,l,r,len)`，最后还可以加一个 `check(len)` 函数用于检查当前内存能否放入 `len` 长度的进程，即判断 `len <= rt->info.sub`。
    注意：线段树中 `update,query` 区间操作时，一定要根据当前节点的 `mid` 位置来指定下一个子节点的移动方向，而不是先进入再遇错返回，这样会浪费很多时间。（本题慢了一倍）
##### 2023.5.7.
49. 2023年XJTU校赛
    场上和wyz一起做出了11道题，拿了校一不错的成绩，下面对剩余4题进行补充：[题面](https://maifile.cn/est/d2636833627652/pdf)
- G.和而不同 - 构造题
    条件非常构造的一道题，构造图的题往往可以从最简单的开始想，本题只要构造出链就完成了，并且链的权重就是从最大的权重向下取整开始(n+1)^2/4，然后后续每个权重依次减一就好了。证明上首先注意到如果长度m相同的两个最短路，它们的长度一定不同，所以只需考虑两个长度相邻的最短路m和m+1，如果这两个长度上不交，则说明任意两个长度的最短路长度都没有交。（只是这个确实太特殊了，用的其实就是归纳法证明）
    长度为m+1的最小边权和为$s1=(k-n+2)+...+(k-n+2+m)=(2k-2n+4+m)(m+1)/2$，长度为m的最小边权和为$s2=k+...+k-m+1=(2k-m+1)m/2$，将二者做差$s1-s2=m^2+2m-nm-n+2+k$，再将$k=(n+1)^2/4$带入，该函数视为$m$为变量，就会发现$f(m)$最小值大于0，所以两最短路一定两两无交。
- O. 打则 - 数学题
    更离谱的一道题，答案就是$n!$，只是要同构证明推导。（还在想）
- J. 大秦酒店欢迎您 - 线段树或莫队（卡常）
- I. 喵喵喵 - 数学题
