---
title: AtCoder Beginner Contest 215 - ABC215
hide: false
math: true
category:
  - coding
  - atcoder
tags:
  - 状压dp
abbrlink: 51581
date: 2021-08-23 14:56:51
index_img:
banner_img:
---

[AtCoder Beginner Contest 215](https://atcoder.jp/contests/arc125)

# E - Chain Contestant

## 题意

给出一个由 $10$ 种大写字母 $A\sim J$ 组成的字符串 $S$，长度为 $N$，求 $S$ 有多少个**下标序列**满足下列条件：

令下标序列所对应的 $S$ 的子序列为 $T$，满足同一种字母在 $T$ 中都是连续出现的，如：`AAABBCCC` 满足条件，但 `AABBACCC` 就不满足条件，因为字母 `A` 不连续。

数据范围：$N\leqslant 1000$

## 思路

看到字母的类型只有10种，而且每一个状态下要保证之前没有出现过该数字，所以可以用dp的一维保存之前出现过的数字，由于最后一位是可以连续的，所以dp还有一维存储最后一位的数字。

先将字母对应成数字 $0\sim9$。

设 $f(i, j, U)$，表示前 $i$ 个字符组成的子序列中，最后一位为 $j$，且使用子序列中包含了集合 $U$ 中的数字。

设 $S_i=x$，则有如下转移：

- $f(i, j, U) = f(i-1, j, U)$ 代表第 $i$ 位不取。

- $f(i, x, U) += f(i-1, x, U)$ 代表取第 $i$ 位，且是上一位取值也是 $x$。

- $f(i, x, V\cup\{x\}) += f(i-1, j, V), (x\not\in V)$ 代表取第 $i$ 位，且是第一次取 $x$。

- $f(i, x, \{x\}) += 1$ 代表只取第 $i$ 位。

则，$\displaystyle \text{ANS} = \sum_{\forall j, U} f(N, j, U)$。

总复杂度 $O(10\times2^{10}\times N)$。

由于dp的第一维可以滚掉，所以就少开了一维。
{% spoiler 点击显/隐代码 %}
```c++
#include <bits/stdc++.h>
#define db double
#define ll long long
#define int ll
#define vi vector<int>
#define vii vector<vi >
#define pii pair<int, int>
#define vp vector<pii >
#define vip vector<vp >
#define mkp make_pair
#define pb push_back
#define Case(x) cout << "Case #" << x << ": "
using namespace std;
const int INF = 0x3f3f3f3f;
const int P = 998244353;
const int N = 1e3 + 10;
int f[10][1<<10], tmp[10][1<<10];
signed main(){
#ifdef _DEBUG
//	FILE *file = freopen("out", "w", stdout);
#endif
	ios::sync_with_stdio(0);
	cin.tie(0);
	int n;
	cin >> n;
	string s;
	cin >> s;
	for (int i = 0; i < n; i++) {
		int x = s[i] - 'A';
		memcpy(tmp, f, sizeof(f));
		for (int k = 0; k < (1<<10); k++) {
			f[x][k] = (f[x][k] + tmp[x][k]) % P;
			if ((k >> x & 1) == 0) {
				for (int j = 0; j < 10; j++) {
					f[x][k | (1<<x)] = (f[x][k | (1<<x)] + tmp[j][k]) % P;
				}
			}
		}
		f[x][1<<x] = (f[x][1<<x] + 1) % P;
	}
	int ans = 0;
	for (int j = 0; j < 10; j++) {
		for (int k = 0; k < (1<<10); k++) {
			ans = (ans + f[j][k]) % P;
		}
	}
	cout << ans << '\n';
	return 0;
}
```
{% endspoiler %}
