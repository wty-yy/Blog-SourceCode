---
title: 2011 MCM-B ä¸­ç»§ç«™åˆ†å¸ƒé—®é¢˜ ç²’å­ç¾¤ç®—æ³•å®ç°
hide: false
math: true
abbrlink: 29177
date: 2022-02-11 12:45:45
index_img:
banner_img:
category:
 - æ•°å­¦å»ºæ¨¡
tags:
 - PSO
---

> è¿™æ¬¡æ˜¯2022ç¾èµ›å‰çš„ä¸€æ¬¡æ¨¡æ‹Ÿèµ›ï¼ŒæŒ‡å¯¼è€å¸ˆç»™å®šäº†2011MCM-Bè¿™é“é¢˜ï¼Œæ­¤é¢˜æ˜¯å¦‚ä½•åˆ†å¸ƒä¸­ç»§ç«™æœ€ä¼˜é—®é¢˜ï¼Œé¢˜ç›®å…ˆæ˜¯ç»™å‡ºäº†ä¸€ç§ä¸­ç»§ç«™åˆ†é…å¸¦å®½çš„ç³»ç»Ÿï¼ˆCTCSSï¼‰ï¼Œå¯ä»¥å°†å¸¦å®½åˆ†ä¸ºå¾ˆå¤šä¸ª `private line(PL)`ï¼Œé€šè¿‡è¿™ä¸ªå¯ä»¥ä¼°è®¡å‡ºåœ¨å¹³å‡äººå£å¯†åº¦ä¸‹ï¼Œæ¯ä¸ªä¸­ç»§ç«™çš„è¦†ç›–åŠå¾„ï¼Œç„¶åæ±‚åœ¨ $40$ è‹±é‡ŒèŒƒå›´ä¸­ï¼Œæœ‰ $1000$ å’Œ $10000$ ä¸ªç”¨æˆ·æ—¶ï¼Œå¦‚ä½•è®¾ç½®ä¸­ç»§ç«™çš„ä½ç½®ï¼Œä½¿å¾—ç”¨æœ€å°‘çš„ä¸­ç»§ç«™å°†æ‰€æœ‰ç”¨æˆ·è¦†ç›–ã€‚æœ€åè®¨è®ºä¸‹åœ¨å±±åŒºç¯å¢ƒä¸‹ä¸­ç»§ç«™åˆ†å¸ƒè¦æ³¨æ„çš„å› ç´ ã€‚

> ä¹‹å‰å­¦ä¹ çš„ç²’å­ç¾¤ç®—æ³•ä¸€èˆ¬ç”¨äºå¯»æ‰¾é«˜ç»´ç©ºé—´ä¸‹çš„æœ€å€¼é—®é¢˜ï¼Œæ¯ä¸ªç²’å­è¿åŠ¨é€Ÿåº¦æ¯æ¬¡éƒ½å¸¦æœ‰éšæœºæ€§ï¼Œä½†æˆ‘ä»¬å¯ä»¥åˆ©ç”¨å®ƒçš„æ€è·¯ï¼Œå°†æ¯ä¸€ä¸ªç²’å­è§†ä¸ºä¸€ä¸ªä¸­ç»§ç«™ï¼Œç„¶åå…ˆå‡åŒ€éšæœºç”Ÿæˆä¸­ç»§ç«™çš„ä½ç½®ï¼Œæ¯ä¸ªç²’å­éƒ½å‘è¿˜æ²¡æœ‰è¢«ä¿¡å·è¦†ç›–çš„ç”¨æˆ·çš„æ–¹å‘å‰è¿›ï¼Œè·ç¦»è¿‘çš„ç§»åŠ¨å¹…åº¦è¾ƒå¤§ï¼Œè·ç¦»è¿œçš„ç§»åŠ¨å¹…åº¦è¾ƒå°ï¼Œå› æ­¤å¯ä»¥å®šä¹‰å‡ºæ¯ä¸ªç²’å­çš„é€Ÿåº¦ï¼Œå†ç»è¿‡è¿­ä»£å°±å¯ä»¥è·å¾—éå¸¸å¥½çš„è§£ã€‚

## é¢˜ç›®

PROBLEM B: Repeater Coordination

- The VHF radio spectrum involves line-of-sight transmission and reception. This limitation can be overcome by â€œrepeaters,â€ which pick up weak signals, amplify them, and retransmit them on a different frequency. Thus, using a repeater, low-power users (such as mobile stations) can communicate with one another in situations where direct user-to-user contact would not be possible. However, repeaters can interfere with one another unless they are far enough apart or transmit on sufficiently separated frequencies.
- In addition to geographical separation, the â€œcontinuous tone-coded squelch systemâ€ (CTCSS), sometimes nicknamed â€œprivate lineâ€ (PL), technology can be used to mitigate interference problems. This system associates to each repeater a separate subaudible tone that is transmitted by all users who wish to communicate through that repeater. The repeater responds only to received signals with its specific PL tone. With this system, two nearby repeaters can share the same frequency pair (for receive and transmit); so more repeaters (and hence more users) can be accommodated in a particular area.
- For a circular flat area of radius 40 miles radius, determine the minimum number of repeaters necessary to accommodate 1,000 simultaneous users. Assume that the spectrum available is 145 to 148 MHz, the transmitter frequency in a repeater is either 600 kHz above or 600 kHz below the receiver frequency, and there are 54 different PL tones available.
- How does your solution change if there are 10,000 users?
- Discuss the case where there might be defects in line-of-sight propagation caused by mountainous areas.

> ä»¥ä¸‹çš„è®¨è®ºéƒ½æ˜¯æ²¡æœ‰éšœç¢ç‰©çš„æƒ…å†µ

## ä¸­ç»§ç«™åŠå¾„è®¡ç®—

- $R$ï¼šæ•´ä¸ªç”¨æˆ·åˆ†å¸ƒåŠå¾„ï¼Œæ­¤é¢˜å– $40$ã€‚
- $r$ï¼šæ¯ä¸ªä¸­ç»§ç«™çš„è¦†ç›–åŠå¾„ã€‚
- $N$ï¼šç”¨æˆ·æ€»é‡ã€‚

ç”¨æˆ·å¯†åº¦å…¬å¼ï¼š

$$
\rho = \frac{N}{\pi R^2}
$$

å®¹é‡å…¬å¼ï¼ˆæ˜¯ä»å¦ä¸€ä¸ªè®ºæ–‡ä¸Šæ¥çš„ï¼‰

$$
\frac{3\sqrt{3}}{2}r^2\rho\leqslant 119
$$

ç»è¿‡è®¡ç®—å¯ä»¥å¾—å‡ºå¦‚ä¸‹å…³ç³»ï¼š

| äººå£æ•°ç›® |  1000   |  2000   |  4000  |  6000  |  8000  | 10000  | 15000  |
| :--------: | :-----: | :-----: | :----: | :----: | :----: | :----: | :----: |
| ä¸­ç»§å™¨åŠå¾„ | 15.1734 | 10.7292 | 7.5867 | 6.1945 | 5.3646 | 4.7982 | 3.9178 |

æœ‰äº†åŠå¾„å°±å¯ä»¥è€ƒè™‘è¦†ç›–ç®—æ³•äº†ã€‚

## æ¨¡å‹

### èœ‚å·¢æ¨¡å‹

è¿™æ˜¯ä¸€ç§éå¸¸ç®€å•çš„æ¨¡å‹ï¼Œå¯ä»¥è¯æ˜ç”¨å¾ˆå¤šä¸ªç›¸åŒåŠå¾„çš„å°åœ†è¦†ç›–å¤§åœ†ï¼Œå®Œå…¨è¦†ç›–çš„æœ€ä¼˜æ–¹æ³•å°±æ˜¯å°†æ¯ä¸ªå°åœ†çš„åœ†å¿ƒè§†ä¸ºå…­è¾¹å½¢çš„ä¸­å¿ƒï¼Œå…­è¾¹å½¢è¾¹é•¿å’Œå°åœ†åŠå¾„ç›¸åŒï¼Œç„¶åå°†å¤§åœ†æ”¾ç½®åˆ°å…­è¾¹å½¢æ„æˆçš„å›¾å½¢ä¸­ï¼Œæœ€åå°†å…­è¾¹å½¢å†æ¢æˆå°åœ†å°±è¡Œäº†ã€‚

![12ä¸ªå°åœ†](https://s4.ax1x.com/2022/02/11/HdwnVH.png)

![12ä¸ªå…­è¾¹å½¢](https://s4.ax1x.com/2022/02/11/Hdwuad.png)

ä¸‹é¢è¿™ä¸ªMATLABä»£ç å¯ä»¥æ‰“å‡º `1~13` ä¸ªå…­è¾¹å½¢èƒ½è¦†ç›–çš„æœ€å¤§åœ†ã€‚

{% spoiler ç‚¹å‡»æ˜¾/éšä»£ç  %}
```matlab
function main
    global R;
    global pos;
    pos = [];
    R = 40/sqrt(7);
    print(12);
    axis equal;
end

function print(n)
    if n >= 1
        drawhex(0, 0);
    end
    if n >= 2
        drawhex(sqrt(3), 0);
    end
    if n >= 3
        drawhex(sqrt(3)/2, 3/2);
    end
    if n >= 4
        drawhex(sqrt(3)/2+sqrt(3), 3/2);
    end
    if n == 5 || n == 6 || n >= 8
        drawhex(sqrt(3)+sqrt(3), 0);
    end
    if n >= 6
        drawhex(sqrt(3), 3);
    end
    if n >= 7
        drawhex(0, 3);
        drawhex(-sqrt(3)/2, 3/2);
    end
    if n >= 9
        drawhex(5*sqrt(3)/2, 3/2);
    end
    if n >= 10
        drawhex(2*sqrt(3), 3);
    end
    if n >= 11
        drawhex(3*sqrt(3)/2, 3+3/2);
    end
    if n >= 12
        drawhex(sqrt(3)/2, 3+3/2);
    end
    if n >= 13
        drawhex(5*sqrt(3)/2, 3+3/2);
    end
    if n == 1
        drawcirc(0, 0, sqrt(3) / 2);
    end
    if n == 2
        drawcirc(0, 0, sqrt(3) / 2);
        axis([-1 2.7 -1 1]);
    end
    if n == 3
        drawcirc(sqrt(3)/2, 1/2, 1);
    end
    if n == 4
        drawcirc(3*sqrt(3)/4, 3/4, sqrt(7)/2);
    end
    if n == 5
        drawcirc(sqrt(3), 3/5, 7/5);
        axis([-1 4.5 -1 1]);
    end
    if n == 6
        drawcirc(sqrt(3), 1, sqrt(3));
    end
    if n == 7 || n == 8 || n == 9
        drawcirc(sqrt(3)/2, 3/2, 2);
        if n == 9
            axis([-1.9 5.35 -1 4]);
        end
    end
    if n == 10 || n == 11
        drawcirc(sqrt(3), 3/2, sqrt(19)/2);
        if n == 10
            axis([-1.9 5.35 -1 4]);
        else
            axis([-1.9 5.35 -1 5.5]);
        end
    end
    if n == 12 || n == 13
        drawcirc(sqrt(3), 2, sqrt(7))
    end
end

function drawhex(dx, dy) 
    dx = dx * 40 / sqrt(7);
    dy = dy * 40 / sqrt(7);
    global R;
    global pos;
    pos = [pos; dx dy];
    t = 0 : pi / 100 : 2 * pi;
    x = R * sin(t);
    y = R * cos(t);
    plot(x + dx, y + dy, 'b');
    hold on
end

function drawcirc(dx, dy, r)
    dx = dx * 40 / sqrt(7);
    dy = dy * 40 / sqrt(7);
    r = r * 40 / sqrt(7);
    t = 0 : pi / 200 : 2 * pi;
    x = r * sin(t);
    y = r * cos(t);
    plot(x + dx, y + dy, 'r');
    hold on
end
```
{% endspoiler %}

ä¸‹é¢è¿™ä¸ªä»£ç èƒ½å¤Ÿæ‰“å°ä»¥ä¸€ä¸ªå…­è¾¹å½¢ä¸ºä¸­å¿ƒï¼Œç”»å‡ºå¯¹åº”çš„åœˆæ•°ä¸‹çš„å›¾åƒ

{% spoiler ç‚¹å‡»æ˜¾/éšä»£ç  %}
```matlab
function main
    global R;
    global pos;
    global mx;
    pos = [];
    mx = [];
    R = 5;
    dfs(6, 0, 0); // è¿™é‡Œå°±æ˜¯ç”»6åœˆ
    t = 0 : pi / 200 : 2 * pi;
    x = 40 * sin(t);
    y = 40 * cos(t);
    plot(x, y, 'r');
    axis equal;
end

function draw(dx, dy) 
    global R;
    t = 0 : pi / 3 : 2 * pi;
    x = R * sin(t);
    y = R * cos(t);
    plot(x + dx, y + dy, 'b');
    hold on
end

function dfs(N, dx, dy)
    if N == 0
        return
    end
    global R;
    global pos;
    global mx;
    [n, ~] = size(pos);
    fg = 0;
    for i = 1 : n
        if (abs(pos(i, 1) - dx) < eps) && (abs(pos(i, 2) - dy) < eps)
            fg = 1;
            if (N <= mx(i))
                return
            else
                mx(i) = N;
            end
        end
    end
    if fg == 0
        pos = [pos; dx dy];
        mx = [mx; N];
    end
    draw(dx, dy);
    xx = R * sqrt(3) / 2;
    yy = R * 3 / 2;
    dfs(N-1, dx + xx, dy + yy);
    dfs(N-1, dx - xx, dy + yy);
    dfs(N-1, dx - xx, dy - yy);
    dfs(N-1, dx + xx, dy - yy);
    xx = sqrt(3) * R;
    dfs(N-1, dx + xx, dy);
    dfs(N-1, dx - xx, dy);
end
```
{% endspoiler %}

é€šè¿‡ä¸Šå›¾å¯ä»¥çœ‹å‡ºï¼Œè¦ç”¨åŠå¾„ä¸º $15.1734$ çš„å°åœ†å®Œå…¨è¦†ç›– $40$ åŠå¾„çš„å¤§åœ†ï¼Œæœ€å°‘è¦ç”¨ $12$ ä¸ªã€‚

ä½†æ˜¯ç°å®æƒ…å†µä¸‹ï¼Œå¹¶ä¸ä¸€å®šè¦æ±‚å…¨è¦†ç›–ï¼Œè€Œä¸”å› ç”¨æˆ·åˆ†å¸ƒçš„ä¸åŒï¼Œä¸­ç»§ç«™çš„å¯†åº¦ä¹Ÿä¼šä¸åŒï¼Œæ‰€ä»¥ç›´æ¥ç”¨èœ‚å·¢æ¨¡å‹å¹¶ä¸èƒ½è¾¾åˆ°æœ€ä¼˜è§£ã€‚

### ç²’å­ç¾¤æ¨¡å‹

ç²’å­ç¾¤æ€è·¯å¾ˆç®€å•ï¼šå°†æ¯ä¸ªä¸­ç»§ç«™è§†ä¸ºä¸€ä¸ªç²’å­ï¼Œæ¯ä¸ªç”¨æˆ·è§†ä¸ºä¸€ä¸ªç‚¹ï¼Œæ¯æ¬¡è¿­ä»£æ—¶ï¼Œç²’å­ä¼šæœ‰ä¸€ä¸ªæ–°çš„é€Ÿåº¦æ–¹å‘ï¼Œæ¯æ¬¡ä¼šå‘è¿™ä¸ªæ–¹å‘ç§»åŠ¨ä¸€æ¬¡ã€‚

æ ¸å¿ƒï¼šç²’å­åªå‘è¿˜æ²¡æœ‰è¢«è¦†ç›–çš„ç‚¹æ–¹å‘ç§»åŠ¨ï¼Œè·ç¦»ç²’å­è¶Šè¿‘çš„ç‚¹å¯¹ç²’å­å¸å¼•åŠ›è¶Šå¼ºï¼Œåä¹‹åˆ™è¶Šå¼±ã€‚ï¼ˆæ­¤å¤„æ»¡è¶³åæ¯”å…³ç³»ï¼Œæ‰€ä»¥å…¬å¼ä¸­æ˜¯åˆ©ç”¨åæ¯”ä¾‹å‡½æ•°å®Œæˆçš„ï¼‰

- $M$ï¼šä¸­ç»§å™¨çš„æ€»æ•°ã€‚
- $v_i(k)$ï¼šç¬¬ $k$ æ¬¡è¿­ä»£æ—¶çš„ç¬¬ $i$ ä¸ªä¸­ç»§å™¨çš„è¿åŠ¨é€Ÿåº¦ã€‚
- $x_i(k)$ï¼šç¬¬ $k$ æ¬¡è¿­ä»£åçš„ç¬¬ $i$ ä¸ªä¸­ç»§å™¨çš„ä½ç½®ã€‚
- $x_j$ï¼šç¬¬ $j$ ä¸ªå‘é€ä¿¡å·çš„äººçš„ä½ç½®ã€‚

P.S. $x_i(k)$ å’Œ $x_j$ çš„ä¸‹æ ‡éƒ½æ˜¯ä» $1$ å¼€å§‹çš„ï¼Œå³ $i\in[1,M]$ï¼Œ$j\in[1,N]$ã€‚

é€Ÿåº¦å˜åŒ–å…¬å¼ï¼š

$$
v_i(k) = w\cdot v_i(k-1)+\sum_{j\in J}a_j\frac{x_i(k-1)-x_j}{|x_i(k-1)-x_j|}
$$

å…¶ä¸­ï¼š$J$ ä¸ºå½“å‰ç¬¬ $k-1$ æ¬¡è¿­ä»£æ—¶ï¼Œæ‰€æœ‰æœªè¢«ä¸­ç»§ç«™è¦†ç›–åˆ°çš„äººçš„ä½ç½®ï¼Œå³

$$
J=\{j\in[1,N]:|x_j-x_i(k-1)|>r, \forall i\in[1,M]\}
$$

$w$ ç§°ä¸ºæƒ¯æ€§æƒé‡ï¼Œ$a_j$ ç§°ä¸ºåŠ é€Ÿåº¦å¸¸æ•°ï¼Œåˆ†åˆ«å–å€¼ä¸ºï¼ˆæ­¤å¤„åˆ©ç”¨äº†åæ¯”ä¾‹å…³ç³»ï¼Œè¦å…ˆå‡æ‰ä¸€ä¸ªå¸¸æ•°ï¼Œä½¿å¾—å˜åŒ–è¾ƒå¤§ä¸€äº›ï¼‰

$$
w=0.6ï¼Œa_j=\frac{1}{|x_i(k-1)-x_j|-r/2}
$$

ä½ç½®å˜åŒ–å…¬å¼ï¼š

$$
x_i(k) = x_i(k-1)+v_i(k)
$$

> æœ€åä¸ºäº†æœ‰ä¸åŒçš„æ•ˆæœè¿˜åˆ¶ä½œäº†ä¸¤ç§ç”¨æˆ·ç”Ÿæˆåˆ†å¸ƒçš„æ–¹æ³•ï¼Œä¸€ç§æ˜¯å‡åŒ€åˆ†å¸ƒï¼Œå¦ä¸€ç§æ˜¯é›†ç¾¤åˆ†å¸ƒï¼ˆæ¨¡æ‹ŸåŸå¸‚å’Œä¹¡æ‘äººå£ï¼‰

> è¿˜åŠ å…¥äº†é¢œè‰²åŒºåˆ«ï¼Œä¸¤ä¸ªç›¸äº¤çš„å°åœ†æ‰€ç”¨çš„é¢œè‰²ä¸èƒ½ç›¸åŒï¼ˆé¿å…ä¿¡å·å†²çªï¼‰

æœ€åå‘ç°ï¼ŒPSOç®—å‡ºçš„ç»“æœè¦å¥½å¾ˆå¤šï¼Œæœ€ä¸‹é¢ä¸¤æ’ä¸ºå®Œå…¨è¦†ç›–æ‰€éœ€çš„ä¸­ç»§ç«™ä¸ªæ•°å…³ç³»å¦‚ä¸‹è¡¨

| äººå£æ•°ç›® |  1000   |  2000   |  4000  |  6000  |  8000  | 10000  | 15000  |
| :--------: | :-----: | :-----: | :----: | :----: | :----: | :----: | :----: |
| åŸå¸‚æ•°ç›® |    4    |    6    |   7    |   7    |   7    |   8    |   8    |
| ä¸­ç»§ç«™åŠå¾„ | 15.1734 | 10.7292 | 7.5867 | 6.1945 | 5.3646 | 4.7982 | 3.9178 |
| å‡åŒ€åˆ†å¸ƒ |    9    |   20    |   39   |   61   |   81   |  100   |  153   |
| é›†ç¾¤åˆ†å¸ƒ |    8    |   18    |   35   |   55   |   74   |   91   |  140   |

æ•ˆæœå›¾ï¼š

![1000 å‡åŒ€åˆ†å¸ƒ](https://s4.ax1x.com/2022/02/11/Hdw3xf.png)

![1000 é›†ä¸­åˆ†å¸ƒ](https://s4.ax1x.com/2022/02/11/HdwlGt.png)

![10000 å‡åŒ€åˆ†å¸ƒ](https://s4.ax1x.com/2022/02/11/Hdw1RP.png)

![10000 é›†ä¸­åˆ†å¸ƒ](https://s4.ax1x.com/2022/02/11/HdwGM8.png)

PSOç®—æ³•éƒ¨åˆ†å‡ç”±C++å®ç°ï¼š

{% spoiler ç‚¹å‡»æ˜¾/éšä»£ç  %}
```c++
// calculate coverage rate
// dye each circle
// add clumped distribution
// Official version
#include <bits/stdc++.h>
#define db double
#define ll long long
#define vi vector<int>
#define pb push_back
using namespace std;
const db PI = M_PI;
const db eps = 1e-8;
const db r = 4.7982; // Radius of repeater
const db R = 40; // Radius of the whole area
const db W = 0.6; // Inertia weights
int N; // Number of repeaters
const int Nmin = 80; // change N in range [Nmin, Nmax]
const int Nmax = 100;
const int M = 10000; // Number of senders
const int T = 3000; // recursion
const int city = 8; // Number of cities
const int cR = 10; // Radius of each city
const db alpha = 0.8; // Proportion of urban population
const int cNum = M * alpha / city; // population of each city
struct Node {
	db x, y; // position
	Node(db x = 0, db y = 0):x(x), y(y) {}
	Node operator * (db c) { return Node(x * c, y * c); }
	Node operator / (db c) { return Node(x / c, y / c); }
	Node operator + (Node b) { return Node(x + b.x, y + b.y); }
	Node operator - (Node b) { return Node(x - b.x, y - b.y); }
	db abs() { return sqrt(x * x + y * y); }
} send[M]; // repeaters, senders, velocity of repeaters, best position before
vi col;
vector<Node> rep, vel;
db dis(Node a, Node b) { return sqrt((a.x-b.x) * (a.x-b.x) + (a.y-b.y)*(a.y-b.y)); }
// return random number between [0,1]
db getrand() { return 1.0 * rand() / RAND_MAX; } 
void initSend(int mode) {
	// initialize senders' position
	if (freopen("sender.txt", "r", stdin) == NULL) {
		// mode = 0 is evenly distribution
		if (!mode) {
			printf("initial evenly distribution\n");
			for (int i = 0; i < M; i++) {
				// argument (the Angle with the x-axis)
				db t = getrand() * 2 * PI;
				// magnitude (the Distance in (0, R))
				db a = sqrt(getrand()) * R;
				send[i].x = cos(t) * a;
				send[i].y = sin(t) * a;
			}
		} else {
			// mode = 1 is clumped distribution
			printf("initial clumped distribution\n");
			vector<Node> City; // save the position of cities
			for (int i = 0; i < (int)(M * alpha); i += cNum) {
				// argument (the Angle with the x-axis)
				db t = getrand() * 2 * PI;
				// magnitude (the Distance in (0, R-cR))
				db a = sqrt(getrand()) * (R - cR);
				// the center coordinate of the city
				db cx = cos(t) * a, cy = sin(t) * a;
				City.pb(Node(cx, cy));
				// Generate city citizens
				for (int j = i; j < i + cNum; j++) {
					db t = getrand() * 2 * PI;
					db a = getrand() * cR;
					send[j].x = cos(t) * a + cx;
					send[j].y = sin(t) * a + cy;
				}
			}
			for (int i = M * alpha, bool fg = 1; i < M; i++) {
				while (fg) {
					fg = 0;
					// Generate countryside citizens
					db t = getrand() * 2 * PI;
					db a = sqrt(getrand()) * R;
					send[i].x = cos(t) * a;
					send[i].y = sin(t) * a;
					// not in any city
					for (auto c : City) if (dis(c, send[i]) < cR) { fg = 1;	break; }
				}
			}
		}
	} else {
		// initialize from the file
		int m;
		scanf("%d", &m);
		assert(m == M);
		for (int i = 0; i < M; i++) scanf("%lf %lf", &send[i].x, &send[i].y);
		fclose(stdin);
	}
}
void initRep() {
	rep = vel = vector<Node>(N);
	// initialize repeaters' position evenly
	for (int i = 0; i < N; i++) {
		db t = getrand() * 2 * PI;
		db a = sqrt(getrand()) * R;
		rep[i].x = cos(t) * a;
		rep[i].y = sin(t) * a;
	}
}
void saveSender() { // save the position of senders
	freopen("sender.txt", "w", stdout);
	printf("%d\n", M);
	for (int i = 0; i < M; i++)	printf("%.3f %.3f\n", send[i].x, send[i].y);
	fclose(stdout);
}
void dye() { // dye the repeaters
	col = vi(N); // save the color id for each repeater
	for (int i = 0; i < N; i++) {
		for (int c = 1; c <= 19; c++) { // color id
			bool fg = 1;
			for (int j = 0; j < N; j++)
				if (dis(rep[i], rep[j]) < 2 * r && col[j] == c) { fg = 0; break; }
			if (fg) { col[i] = c; break; }
		}
	}
}
void saveRepeater(int num) { // save the position of repeaters
	dye();
	// Example:
	// "repeater9_1000.txt" means there are 9 repeaters and iterate 1000 times
	string s = "repeater" + to_string(N) + "_" + to_string(num) + ".txt";
	freopen(s.c_str(), "w", stdout);
	printf("%d\n", N);
	for (int i = 0; i < N; i++)
		printf("%.3f %.3f %d\n", rep[i].x, rep[i].y, col[i]);
	fclose(stdout);
}
bool cov(Node sender) { // judge whether sender has been covered
	for (int i = 0; i < N; i++)
		if (dis(sender, rep[i]) < r)
			return 1;
	return 0;
}
void PSO() {
	saveRepeater(0); // save start status
	for (int _i = 0; _i < T; _i++) {
		vector<Node> out; // senders who haven't been covered
		for (int j = 0; j < M; j++)
			if (!cov(send[j]))
				out.pb(send[j]);
		if (out.size()) {
			for (int i = 0; i < N; i++) {
				vel[i] = vel[i] * W; // multiply the weight
				Node dv;
				for (Node sender : out) {
					Node t = sender - rep[i];
					int len = t.abs();
					dv = dv + (t / (len * (len - r / 2)));
				}
				dv = dv / out.size(); // get the average
				vel[i] = vel[i] + dv; // update the velocity
				rep[i] = rep[i] + vel[i]; // move the repeater
			}
		}
	}
	saveRepeater(T); // save end status
}
db calcRate() { // calculate the coverage rate
	int tot = 0; // total covered senders
	for (int j = 0; j < M; j++)
		if (cov(send[j]))
			tot++;
	return 1.0 * tot / M;
}
signed main() {
	srand(time(NULL));
	initSend(0);
	saveSender();
	for (N = Nmin; N <= Nmax; N++) {
		initRep();
		PSO();
		int mxCol = 0;
		for (int i = 0; i < N; i++) mxCol = max(mxCol, col[i]);
		freopen("/dev/tty", "w", stdout);
		// print the number of repeaters, coverage rate and the number of colors used
		printf("%d %f %d\n", N, calcRate(), mxCol);
	}
	return 0;
}
```
{% endspoiler %}

ç»˜å›¾éƒ¨åˆ†ç”±MATLABå®ç°ï¼Œåªéœ€å°† `sender.txt` å’Œ `repeater*` è¿™äº›æ–‡ä»¶æ‹·è´åˆ°MATLABç›®å½•ä¸‹å³å¯ï¼Œå¯ä»¥é€‰æ‹©æ‰“å°å¯¹åº”çš„åœˆçš„ä¸ªæ•°å’Œè¿­ä»£æ¬¡æ•°ï¼Œåªéœ€é€‰å–å¯¹åº”çš„æ–‡ä»¶å³å¯ã€‚

{% spoiler ç‚¹å‡»æ˜¾/éšä»£ç  %}
```matlab
% draw different colors for each circle
function main
    col = ["#F44336";"#9C27B0";"#3F51B5";"#03A9F4";"#009688";"#8BC34A";"#FFEB3B";"#FF9800";"#795548";"#607D8B";"#D81B60";"#5E35B1";"#1E88E5";"#00ACC1";"#43A047";"#C0CA33";"#FFB300";"#F4511E";"#757575"];
    R = 40;
    r = 15.17;
    %r = 4.7982;
    id = fopen('sender.txt', 'r');
    m = fscanf(id, '%d', 1);
    w = fscanf(id, '%f', [2, m]);
    x = w(1, :);
    y = w(2, :);
    plot(x, y, '.', 'color', '#546E7A');
    hold on
    t = 0 : pi / 100 : 2 * pi;
    x = cos(t);
    y = sin(t);
    plot(x * R, y * R, 'k');
    hold on
    axis equal
    for i = [3000]
		% "repeater9_1000.txt" means there are 9 repeaters and iterate 1000 times
        s = "repeater8_" + string(i) + ".txt";
        id = fopen(s, 'r');
        n = fscanf(id, '%d', 1);
        w = fscanf(id, '%f', [3, m]);
        dx = w(1, :);
        dy = w(2, :);
        c = w(3, :);
        for j = 1 : n
            plot(x * r + dx(j), y * r + dy(j), 'color', col(c(j)), 'linewidth', 1.5);
        end
    end
end
```
{% endspoiler %}

æœ€éº»çƒ¦çš„å°±æ˜¯ç²’å­ç¾¤ç®—æ³•ä¸­é€Ÿåº¦å®šä¹‰ï¼Œè¿™ä¸ªå‚æ•°çœŸæ»´éš¾è°ƒï¼Œæ²¡è°ƒå‡ºæ¥æ—¶å€™éƒ½ä¸æ™“å¾—èƒ½ä¸èƒ½ç”¨ï¼ˆæœ‰ç‚¹è‡ªé—­äº†ğŸ¤¢ï¼‰ï¼Œåå¤å°è¯•è°ƒå‡ºæ¥åï¼Œæ‰å‘ç°å¯ä»¥çš„ğŸ˜†ï¼Œè€Œä¸”æ•ˆæœä¸é”™ã€‚

æœ€åè¿˜æ˜¯è¦æ„Ÿè°¢é˜Ÿå‹çš„æ”¯æŒå’Œå…±åŒåŠªåŠ›ï¼Œå®Œæˆäº†æ•´ç¯‡è®ºæ–‡çš„å†™ä½œéƒ¨åˆ†ğŸ˜‰

## æ€»ç»“

> è¿™é‡Œæ€»ç»“ä¸€ä¸‹è¿™æ¬¡å­¦åˆ°çš„æœ‰æ„æ€çš„ä¸œè¥¿

ä¸¤ä¸ªç½‘å€ï¼š

1. [AIæ”¾å¤§å›¾ç‰‡](https://bigjpg.com/)ï¼šæ•ˆæœéå¸¸å¥½ï¼Œå¯ä»¥åœ¨æ”¾ä¸Šè®ºæ–‡å‰å…ˆæ”¾å¤§ä¸€éã€‚

2. [å¥½ç”¨çš„é¢œè‰²æ­é…ç½‘ç«™](https://materialui.co/)ï¼šåœ¨é€‰å–ä¸åŒçš„å°åœˆé¢œè‰²æ—¶ä½¿ç”¨çš„ï¼ˆæˆ‘æ ¹æœ¬ä¸ä¼šæ­é…é¢œè‰²ï¼Œè¿™ä¸ªç½‘ç«™çœŸçš„å¥½ç”¨ï¼‰
